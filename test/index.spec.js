import { env, createExecutionContext, waitOnExecutionContext } from 'cloudflare:test';
import { describe, it, expect, beforeEach } from 'vitest';
import worker from '../src';

const v1ApiPrefix = 'api/v1';

// Set test secrets for all tests
beforeEach(() => {
	env.SERVER_PEPPER = 'test-server-pepper-32-bytes-for-hmac-sha256-security-ok';
	env.JWT_SECRET = 'test-jwt-secret-key-32-bytes-for-hmac-sha256-signing-ok';
});

describe('CryptDrive Worker', () => {
	beforeEach(async () => {
		// Clean up database before each test
		try {
			await env.DB.prepare('DELETE FROM users').run();
			await env.DB.prepare('DELETE FROM files').run();
		} catch {
			// Tables might not exist yet, that's ok
		}
	});

	describe('Security', () => {
		it('returns 500 when SERVER_PEPPER is missing', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: btoa('a'.repeat(32)), keychain_id: crypto.randomUUID() }),
			});

			// Create a temporary env without SERVER_PEPPER
			const testEnv = { ...env, SERVER_PEPPER: undefined };
			const ctx = createExecutionContext();
			const response = await worker.fetch(request, testEnv, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(500);
			const data = await response.json();
			expect(data.error).toBe('Server error.');
		});

		it('returns 500 when JWT_SECRET is missing', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: btoa('a'.repeat(32)), keychain_id: crypto.randomUUID() }),
			});

			// Create a temporary env without JWT_SECRET
			const testEnv = { ...env, JWT_SECRET: undefined };
			const ctx = createExecutionContext();
			const response = await worker.fetch(request, testEnv, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(500);
			const data = await response.json();
			expect(data.error).toBe('Server error.');
		});

		it('works when both secrets are present', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: btoa('a'.repeat(32)), keychain_id: crypto.randomUUID() }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(201);
		});
	});

	describe('POST /user', () => {
		it('creates a new user with valid public key', async () => {
			const publicKey = btoa('a'.repeat(32)); // 32-byte key encoded as base64

			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: publicKey, keychain_id: crypto.randomUUID() }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(201);

			const data = await response.json();
			expect(data).toHaveProperty('user_id');
			expect(typeof data.user_id).toBe('string');

			// Verify UUID format
			const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
			expect(data.user_id).toMatch(uuidRegex);
		});

		it('creates user in database with correct data', async () => {
			const publicKey = btoa('b'.repeat(32));
			const keychainId = crypto.randomUUID();

			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: publicKey, keychain_id: keychainId }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			const data = await response.json();

			// Check database
			const user = await env.DB.prepare('SELECT * FROM users WHERE user_id = ?').bind(data.user_id).first();

			expect(user).toBeTruthy();
			expect(user.public_key).toBe(publicKey);
		});

		it('creates empty keychain file in R2', async () => {
			const publicKey = btoa('c'.repeat(32));

			// Keychain ID placeholder that would be generated by the client in a real scenario
			const keychainId = crypto.randomUUID();

			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: publicKey, keychain_id: keychainId }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(201);

			// Check R2 bucket
			const keychainObject = await env.BUCKET.get(`${keychainId}`);
			expect(keychainObject).toBeTruthy();
		});

		it('rejects request without public_key', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('public_key');
		});

		it('rejects invalid base64 public key', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: 'not-valid-base64!!!', keychain_id: crypto.randomUUID() }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('base64');
		});

		it('rejects public key with wrong length', async () => {
			const shortKey = btoa('short'); // Less than 32 bytes

			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: shortKey, keychain_id: crypto.randomUUID() }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('32-byte');
		});

		it('rejects duplicate public key', async () => {
			const publicKey = btoa('d'.repeat(32));

			// First request - should succeed
			const request1 = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: publicKey, keychain_id: crypto.randomUUID() }),
			});

			const ctx1 = createExecutionContext();
			const response1 = await worker.fetch(request1, env, ctx1);
			await waitOnExecutionContext(ctx1);
			expect(response1.status).toBe(201);

			// Second request with same public key - should fail
			const request2 = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: publicKey, keychain_id: crypto.randomUUID() }),
			});

			const ctx2 = createExecutionContext();
			const response2 = await worker.fetch(request2, env, ctx2);
			await waitOnExecutionContext(ctx2);

			expect(response2.status).toBe(409);
			const data = await response2.json();
			expect(data.error).toContain('already registered');
		});

		it('rejects invalid JSON', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: 'invalid json{',
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('Invalid JSON');
		});
	});

	describe('CORS', () => {
		it('handles OPTIONS preflight request', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'OPTIONS',
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(200);
			expect(response.headers.get('Access-Control-Allow-Origin')).not.toBe('*');
			expect(response.headers.get('Access-Control-Allow-Methods')).toContain('POST');
		});
	});

	describe('404 handling', () => {
		it('returns 404 for unknown routes', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/unknown`);

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(404);
			const data = await response.json();
			expect(data.error).toBe('Not found');
		});
	});

	describe('POST /auth/token', () => {
		let testUserId;
		let testPublicKey;

		beforeEach(async () => {
			// Create a test user first
			testPublicKey = btoa('e'.repeat(32));

			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: testPublicKey, keychain_id: crypto.randomUUID() }),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			const data = await response.json();
			testUserId = data.user_id;
		});

		it('returns challenge JWT for initial request', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: null,
					signature: null,
				}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(200);

			const data = await response.json();
			expect(data).toHaveProperty('challenge');
			expect(typeof data.challenge).toBe('string');

			// Challenge should be a JWT (3 parts separated by dots)
			expect(data.challenge.split('.')).toHaveLength(3);
		});

		it('challenge JWT contains correct payload', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: null,
					signature: null,
				}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			const data = await response.json();

			// Decode payload (middle part of JWT)
			const payloadPart = data.challenge.split('.')[1];
			const payloadJson = atob(payloadPart.replace(/-/g, '+').replace(/_/g, '/'));
			const payload = JSON.parse(payloadJson);

			expect(payload.user_id).toBe(testUserId);
			expect(payload.nonce).toBeTruthy();
			expect(payload.nonce.length).toBe(64); // 32 bytes as hex
			expect(payload.iat).toBeTruthy();
			expect(payload.exp).toBeTruthy();
			expect(payload.exp - payload.iat).toBe(300); // 5 minutes
		});

		it('rejects request without user_id', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('public_key');
		});

		it('rejects request for non-existent user', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: 'nonexistentpublickey==',
					challenge: null,
					signature: null,
				}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(404);
			const data = await response.json();
			expect(data.error).toBe('User not found');
		});

		it('rejects when only challenge provided', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: 'some.jwt.token',
					signature: null,
				}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('Both challenge and signature');
		});

		it('rejects when only signature provided', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: null,
					signature: 'somesignature',
				}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('Both challenge and signature');
		});

		it('rejects invalid challenge JWT', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: 'invalid.jwt.token',
					signature: btoa('f'.repeat(64)),
				}),
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toContain('Invalid challenge');
		});

		it('rejects when public_key does not match challenge', async () => {
			// Get a challenge for one user
			const request1 = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: null,
					signature: null,
				}),
			});

			const ctx1 = createExecutionContext();
			const response1 = await worker.fetch(request1, env, ctx1);
			await waitOnExecutionContext(ctx1);
			const data1 = await response1.json();

			// Try to use it with a different user_id
			const request2 = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: 'nonexistentpublickey==',
					challenge: data1.challenge,
					signature: btoa('g'.repeat(64)),
				}),
			});

			const ctx2 = createExecutionContext();
			const response2 = await worker.fetch(request2, env, ctx2);
			await waitOnExecutionContext(ctx2);

			expect(response2.status).toBe(404); // User not found first
		});

		it('rejects invalid signature', async () => {
			// Get a valid challenge
			const request1 = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: null,
					signature: null,
				}),
			});

			const ctx1 = createExecutionContext();
			const response1 = await worker.fetch(request1, env, ctx1);
			await waitOnExecutionContext(ctx1);
			const data1 = await response1.json();

			// Try to verify with invalid signature
			const request2 = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: data1.challenge,
					signature: btoa('h'.repeat(64)), // Invalid signature
				}),
			});

			const ctx2 = createExecutionContext();
			const response2 = await worker.fetch(request2, env, ctx2);
			await waitOnExecutionContext(ctx2);

			expect(response2.status).toBe(401);
			const data2 = await response2.json();
			expect(data2.error).toBe('Invalid signature');
		});

		it('rejects invalid JSON', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: 'invalid json{',
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(400);
			const data = await response.json();
			expect(data.error).toBe('Invalid JSON');
		});
	});

	describe('GET /files', () => {
		let testUserId;
		let testPublicKey;
		let testToken;

		beforeEach(async () => {
			// Create a test user
			testPublicKey = btoa('f'.repeat(32));

			const createUserRequest = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: testPublicKey, keychain_id: crypto.randomUUID() }),
			});

			let ctx = createExecutionContext();
			const createUserResponse = await worker.fetch(createUserRequest, env, ctx);
			await waitOnExecutionContext(ctx);

			const userData = await createUserResponse.json();
			testUserId = userData.user_id;

			// Get authentication challenge
			const challengeRequest = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: null,
					signature: null,
				}),
			});

			ctx = createExecutionContext();
			await worker.fetch(challengeRequest, env, ctx);
			await waitOnExecutionContext(ctx);

			// For testing, we'll manually create a valid token
			// In real usage, the client would sign the challenge
			// We'll use the internal createJWT function by creating a valid token
			const jwtSecret = env.JWT_SECRET || 'default-jwt-secret-change-in-production';

			// Create a token directly (simulating successful authentication)
			const now = Math.floor(Date.now() / 1000);
			const payload = {
				sub: testPublicKey,
				iat: now,
				exp: now + 3600,
			};

			// Manual JWT creation for testing
			const header = { alg: 'HS256', typ: 'JWT' };
			const encodedHeader = btoa(JSON.stringify(header)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
			const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
			const data = `${encodedHeader}.${encodedPayload}`;

			const encoder = new TextEncoder();
			const key = await crypto.subtle.importKey('raw', encoder.encode(jwtSecret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

			const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
			const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
				.replace(/\+/g, '-')
				.replace(/\//g, '_')
				.replace(/=/g, '');

			testToken = `${data}.${encodedSignature}`;
		});

		it('returns empty list for user with no files', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
				headers: { Authorization: `Bearer ${testToken}` },
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(200);
			const data = await response.json();
			expect(data).toHaveProperty('files');
			expect(Array.isArray(data.files)).toBe(true);
			expect(data.files.length).toBe(0);
		});

		it('returns list of files owned by user', async () => {
			// Insert some test files directly into the database
			const fileId1 = crypto.randomUUID();
			const fileId2 = crypto.randomUUID();
			const ownerHash = await computeOwnerHashForTest(testPublicKey, env);

			await env.DB.prepare('INSERT INTO files (file_id, owner_hash, size, created_at, updated_at) VALUES (?, ?, ?, ?, ?)')
				.bind(fileId1, ownerHash, 1234, '2026-02-03T10:00:00Z', '2026-02-03T10:00:00Z')
				.run();

			await env.DB.prepare('INSERT INTO files (file_id, owner_hash, size, created_at, updated_at) VALUES (?, ?, ?, ?, ?)')
				.bind(fileId2, ownerHash, 5678, '2026-02-03T11:00:00Z', '2026-02-03T11:00:00Z')
				.run();

			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
				headers: { Authorization: `Bearer ${testToken}` },
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(200);
			const data = await response.json();
			expect(data.files).toHaveLength(2);

			// Should be sorted by created_at DESC
			expect(data.files[0].file_id).toBe(fileId2);
			expect(data.files[0].size).toBe(5678);
			expect(data.files[0].created_at).toBe('2026-02-03T11:00:00Z');
			expect(data.files[0].updated_at).toBe('2026-02-03T11:00:00Z');

			expect(data.files[1].file_id).toBe(fileId1);
			expect(data.files[1].size).toBe(1234);
		});

		it('only returns files owned by authenticated user', async () => {
			// Create another user
			const otherPublicKey = btoa('g'.repeat(32));
			const createOtherUserRequest = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: otherPublicKey, keychain_id: crypto.randomUUID() }),
			});

			let ctx = createExecutionContext();
			const createOtherUserResponse = await worker.fetch(createOtherUserRequest, env, ctx);
			await waitOnExecutionContext(ctx);
			const otherUserData = await createOtherUserResponse.json();

			// Insert files for both users
			const myFileId = crypto.randomUUID();
			const otherFileId = crypto.randomUUID();
			const myOwnerHash = await computeOwnerHashForTest(testPublicKey, env);
			const otherOwnerHash = await computeOwnerHashForTest(otherUserData.public_key, env);

			await env.DB.prepare('INSERT INTO files (file_id, owner_hash, size, created_at, updated_at) VALUES (?, ?, ?, ?, ?)')
				.bind(myFileId, myOwnerHash, 1111, '2026-02-03T10:00:00Z', '2026-02-03T10:00:00Z')
				.run();

			await env.DB.prepare('INSERT INTO files (file_id, owner_hash, size, created_at, updated_at) VALUES (?, ?, ?, ?, ?)')
				.bind(otherFileId, otherOwnerHash, 2222, '2026-02-03T10:00:00Z', '2026-02-03T10:00:00Z')
				.run();

			// Query with first user's token
			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
				headers: { Authorization: `Bearer ${testToken}` },
			});

			ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(200);
			const data = await response.json();
			expect(data.files).toHaveLength(1);
			expect(data.files[0].file_id).toBe(myFileId);
		});

		it('rejects request without Authorization header', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(401);
			const data = await response.json();
			expect(data.error).toContain('Authorization');
		});

		it('rejects request with invalid token', async () => {
			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
				headers: { Authorization: 'Bearer invalid.token.here' },
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(401);
			const data = await response.json();
			expect(data.error).toContain('Invalid or expired token');
		});

		it('rejects request with expired token', async () => {
			// Create an expired token
			const jwtSecret = env.JWT_SECRET || 'default-jwt-secret-change-in-production';
			const now = Math.floor(Date.now() / 1000);
			const payload = {
				sub: testUserId,
				iat: now - 7200,
				exp: now - 3600, // Expired 1 hour ago
			};

			const header = { alg: 'HS256', typ: 'JWT' };
			const encodedHeader = btoa(JSON.stringify(header)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
			const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
			const data = `${encodedHeader}.${encodedPayload}`;

			const encoder = new TextEncoder();
			const key = await crypto.subtle.importKey('raw', encoder.encode(jwtSecret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

			const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
			const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
				.replace(/\+/g, '-')
				.replace(/\//g, '_')
				.replace(/=/g, '');
			const expiredToken = `${data}.${encodedSignature}`;

			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
				headers: { Authorization: `Bearer ${expiredToken}` },
			});

			const ctx = createExecutionContext();
			const response = await worker.fetch(request, env, ctx);
			await waitOnExecutionContext(ctx);

			expect(response.status).toBe(401);
			const data2 = await response.json();
			expect(data2.error).toContain('expired');
		});

		describe('POST /file - Create file', () => {
			it('successfully creates a file with valid data', async () => {
				// Create a properly formatted file with magic bytes, version, nonce, encrypted data, and tag
				const magic = new TextEncoder().encode('SECF');
				const version = new Uint8Array([0x01]);
				const nonce = new Uint8Array(12);
				crypto.getRandomValues(nonce);

				// Simulated encrypted payload (filename_length + filename + content)
				const filename = 'test.txt';
				const filenameBytes = new TextEncoder().encode(filename);
				const filenameLength = new Uint8Array(2);
				new DataView(filenameLength.buffer).setUint16(0, filenameBytes.length, false);
				const content = new TextEncoder().encode('Hello, World!');
				const payload = new Uint8Array([...filenameLength, ...filenameBytes, ...content]);

				// Simulated authentication tag (16 bytes)
				const tag = new Uint8Array(16);
				crypto.getRandomValues(tag);

				// Combine all parts
				const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: { Authorization: `Bearer ${testToken}` },
					body: fileData,
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				expect(response.status).toBe(201);
				const data = await response.json();
				expect(data.file_id).toBeDefined();
				expect(data.file_id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);

				// Verify file was stored in R2
				const storedFile = await env.BUCKET.get(data.file_id);
				expect(storedFile).not.toBeNull();
				const storedData = await storedFile.arrayBuffer();
				expect(new Uint8Array(storedData)).toEqual(fileData);

				// Verify metadata was stored in D1
				const result = await env.DB.prepare('SELECT * FROM files WHERE file_id = ?').bind(data.file_id).first();

				expect(result).not.toBeNull();
				expect(result.file_id).toBe(data.file_id);
				expect(result.owner_hash).toBe(await computeOwnerHashForTest(testPublicKey, env));
				expect(result.size).toBe(fileData.byteLength);
				expect(result.created_at).toBeDefined();
				expect(result.updated_at).toBeDefined();
			});

			it('rejects request without authentication', async () => {
				const magic = new TextEncoder().encode('SECF');
				const version = new Uint8Array([0x01]);
				const nonce = new Uint8Array(12);
				const payload = new Uint8Array(20);
				const tag = new Uint8Array(16);
				const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					body: fileData,
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				expect(response.status).toBe(401);
				const data = await response.json();
				expect(data.error).toContain('Authorization header required');
			});

			it('rejects empty file data', async () => {
				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: { Authorization: `Bearer ${testToken}` },
					body: new Uint8Array(0),
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				expect(response.status).toBe(400);
				const data = await response.json();
				expect(data.error).toBe('File data is required');
			});

			it('rejects file with invalid magic bytes', async () => {
				const magic = new TextEncoder().encode('XXXX');
				const version = new Uint8Array([0x01]);
				const nonce = new Uint8Array(12);
				const payload = new Uint8Array(20);
				const tag = new Uint8Array(16);
				const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: { Authorization: `Bearer ${testToken}` },
					body: fileData,
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				expect(response.status).toBe(400);
				const data = await response.json();
				expect(data.error).toContain('Invalid file format: invalid magic bytes');
			});

			it('rejects file with invalid version', async () => {
				const magic = new TextEncoder().encode('SECF');
				const version = new Uint8Array([0x99]); // Invalid version
				const nonce = new Uint8Array(12);
				const payload = new Uint8Array(20);
				const tag = new Uint8Array(16);
				const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: { Authorization: `Bearer ${testToken}` },
					body: fileData,
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				expect(response.status).toBe(400);
				const data = await response.json();
				expect(data.error).toContain('Invalid file format: unsupported version');
			});

			it('rejects file that is too small', async () => {
				const fileData = new Uint8Array(10); // Less than 33 bytes minimum

				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: { Authorization: `Bearer ${testToken}` },
					body: fileData,
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				expect(response.status).toBe(400);
				const data = await response.json();
				expect(data.error).toContain('Invalid file format: file too small');
			});

			it('creates multiple files for same user', async () => {
				const createFile = async () => {
					const magic = new TextEncoder().encode('SECF');
					const version = new Uint8Array([0x01]);
					const nonce = new Uint8Array(12);
					crypto.getRandomValues(nonce);
					const payload = new Uint8Array(20);
					crypto.getRandomValues(payload);
					const tag = new Uint8Array(16);
					crypto.getRandomValues(tag);
					const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

					const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
						method: 'POST',
						headers: { Authorization: `Bearer ${testToken}` },
						body: fileData,
					});

					const ctx = createExecutionContext();
					const response = await worker.fetch(request, env, ctx);
					await waitOnExecutionContext(ctx);
					return response.json();
				};

				const file1 = await createFile();
				const file2 = await createFile();

				expect(file1.file_id).toBeDefined();
				expect(file2.file_id).toBeDefined();
				expect(file1.file_id).not.toBe(file2.file_id);

				// Verify both files exist in database
				const files = await env.DB.prepare('SELECT * FROM files WHERE file_id IN (?, ?)').bind(file1.file_id, file2.file_id).all();

				expect(files.results.length).toBe(2);
			});

			it('stores file with correct owner_hash', async () => {
				const magic = new TextEncoder().encode('SECF');
				const version = new Uint8Array([0x01]);
				const nonce = new Uint8Array(12);
				const payload = new Uint8Array(20);
				const tag = new Uint8Array(16);
				const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: { Authorization: `Bearer ${testToken}` },
					body: fileData,
				});

				const ctx = createExecutionContext();
				const response = await worker.fetch(request, env, ctx);
				await waitOnExecutionContext(ctx);

				const data = await response.json();
				const expectedOwnerHash = await computeOwnerHashForTest(testPublicKey, env);

				const result = await env.DB.prepare('SELECT owner_hash FROM files WHERE file_id = ?').bind(data.file_id).first();

				expect(result.owner_hash).toBe(expectedOwnerHash);
			});
		});
	});
});

describe('PUT /file/:file_id - Update file', () => {
	let testUserId;
	let testPublicKey;
	let testToken;
	let testFileId;

	beforeEach(async () => {
		// Clean up database before each test
		try {
			await env.DB.prepare('DELETE FROM users').run();
			await env.DB.prepare('DELETE FROM files').run();
		} catch {
			// Tables might not exist yet, that's ok
		}

		// Create a test user
		testPublicKey = btoa('h'.repeat(32));

		const createUserRequest = new Request(`http://example.com/${v1ApiPrefix}/user`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ public_key: testPublicKey, keychain_id: crypto.randomUUID() }),
		});

		let ctx = createExecutionContext();
		const createUserResponse = await worker.fetch(createUserRequest, env, ctx);
		await waitOnExecutionContext(ctx);

		const userData = await createUserResponse.json();
		testUserId = userData.user_id;

		// Create an authentication token
		const jwtSecret = env.JWT_SECRET || 'default-jwt-secret-change-in-production';
		const now = Math.floor(Date.now() / 1000);
		const payload = {
			sub: testUserId,
			iat: now,
			exp: now + 3600,
		};

		const header = { alg: 'HS256', typ: 'JWT' };
		const encodedHeader = btoa(JSON.stringify(header)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const data = `${encodedHeader}.${encodedPayload}`;

		const encoder = new TextEncoder();
		const key = await crypto.subtle.importKey('raw', encoder.encode(jwtSecret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

		const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
		const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
			.replace(/\+/g, '-')
			.replace(/\//g, '_')
			.replace(/=/g, '');
		testToken = `${data}.${encodedSignature}`;

		// Create a test file
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		crypto.getRandomValues(nonce);
		const payload2 = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload2, ...tag]);

		const createFileRequest = new Request(`http://example.com/${v1ApiPrefix}/file`, {
			method: 'POST',
			headers: { Authorization: `Bearer ${testToken}` },
			body: fileData,
		});

		ctx = createExecutionContext();
		const createFileResponse = await worker.fetch(createFileRequest, env, ctx);
		await waitOnExecutionContext(ctx);

		const fileResult = await createFileResponse.json();
		testFileId = fileResult.file_id;
	});

	it('successfully updates a file with valid data', async () => {
		// Create new file data
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		crypto.getRandomValues(nonce);
		const payload = new Uint8Array(30); // Different size
		crypto.getRandomValues(payload);
		const tag = new Uint8Array(16);
		crypto.getRandomValues(tag);
		const newFileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${testToken}` },
			body: newFileData,
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(200);
		const data = await response.json();
		expect(data.success).toBe(true);
		expect(data.updated_at).toBeDefined();

		// Verify file was updated in R2
		const storedFile = await env.BUCKET.get(testFileId);
		expect(storedFile).not.toBeNull();
		const storedData = await storedFile.arrayBuffer();
		expect(new Uint8Array(storedData)).toEqual(newFileData);

		// Verify metadata was updated in D1
		const result = await env.DB.prepare('SELECT * FROM files WHERE file_id = ?').bind(testFileId).first();

		expect(result.size).toBe(newFileData.byteLength);
		expect(result.updated_at).toBe(data.updated_at);
	});

	it('rejects update without authentication', async () => {
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		const payload = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			body: fileData,
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(401);
		const data = await response.json();
		expect(data.error).toContain('Authorization header required');
	});

	it('rejects update of non-existent file', async () => {
		const fakeFileId = crypto.randomUUID();
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		const payload = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${fakeFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${testToken}` },
			body: fileData,
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(404);
		const data = await response.json();
		expect(data.error).toBe('File not found');
	});

	it('rejects update by non-owner', async () => {
		// Create another user
		const otherPublicKey = btoa('i'.repeat(32));
		const createUserRequest = new Request(`http://example.com/${v1ApiPrefix}/user`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ public_key: otherPublicKey, keychain_id: crypto.randomUUID() }),
		});

		let ctx = createExecutionContext();
		const createUserResponse = await worker.fetch(createUserRequest, env, ctx);
		await waitOnExecutionContext(ctx);

		const otherUserData = await createUserResponse.json();
		const otherUserId = otherUserData.user_id;

		// Create token for other user
		const jwtSecret = env.JWT_SECRET || 'default-jwt-secret-change-in-production';
		const now = Math.floor(Date.now() / 1000);
		const payload = {
			sub: otherUserId,
			iat: now,
			exp: now + 3600,
		};

		const header = { alg: 'HS256', typ: 'JWT' };
		const encodedHeader = btoa(JSON.stringify(header)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const data = `${encodedHeader}.${encodedPayload}`;

		const encoder = new TextEncoder();
		const key = await crypto.subtle.importKey('raw', encoder.encode(jwtSecret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

		const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
		const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
			.replace(/\+/g, '-')
			.replace(/\//g, '_')
			.replace(/=/g, '');
		const otherToken = `${data}.${encodedSignature}`;

		// Try to update file with other user's token
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		const payload2 = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload2, ...tag]);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${otherToken}` },
			body: fileData,
		});

		ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(403);
		const responseData = await response.json();
		expect(responseData.error).toBe('Not file owner');
	});

	it('rejects empty file data', async () => {
		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${testToken}` },
			body: new Uint8Array(0),
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(400);
		const data = await response.json();
		expect(data.error).toBe('File data is required');
	});

	it('rejects file with invalid magic bytes', async () => {
		const magic = new TextEncoder().encode('XXXX');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		const payload = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${testToken}` },
			body: fileData,
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(400);
		const data = await response.json();
		expect(data.error).toContain('Invalid file format: invalid magic bytes');
	});

	it('rejects file with invalid version', async () => {
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x99]);
		const nonce = new Uint8Array(12);
		const payload = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload, ...tag]);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${testToken}` },
			body: fileData,
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(400);
		const data = await response.json();
		expect(data.error).toContain('Invalid file format: unsupported version');
	});

	it('rejects file that is too small', async () => {
		const fileData = new Uint8Array(10);

		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'PUT',
			headers: { Authorization: `Bearer ${testToken}` },
			body: fileData,
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(400);
		const data = await response.json();
		expect(data.error).toContain('Invalid file format: file too small');
	});
});

describe('DELETE /file/:file_id - Delete file', () => {
	let testUserId;
	let testPublicKey;
	let testToken;
	let testFileId;

	beforeEach(async () => {
		// Clean up database before each test
		try {
			await env.DB.prepare('DELETE FROM users').run();
			await env.DB.prepare('DELETE FROM files').run();
		} catch {
			// Tables might not exist yet, that's ok
		}

		// Create a test user
		testPublicKey = btoa('j'.repeat(32));

		const createUserRequest = new Request(`http://example.com/${v1ApiPrefix}/user`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ public_key: testPublicKey, keychain_id: crypto.randomUUID() }),
		});

		let ctx = createExecutionContext();
		const createUserResponse = await worker.fetch(createUserRequest, env, ctx);
		await waitOnExecutionContext(ctx);

		const userData = await createUserResponse.json();
		testUserId = userData.user_id;

		// Create an authentication token
		const jwtSecret = env.JWT_SECRET || 'default-jwt-secret-change-in-production';
		const now = Math.floor(Date.now() / 1000);
		const payload = {
			sub: testUserId,
			iat: now,
			exp: now + 3600,
		};

		const header = { alg: 'HS256', typ: 'JWT' };
		const encodedHeader = btoa(JSON.stringify(header)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const data = `${encodedHeader}.${encodedPayload}`;

		const encoder = new TextEncoder();
		const key = await crypto.subtle.importKey('raw', encoder.encode(jwtSecret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

		const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
		const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
			.replace(/\+/g, '-')
			.replace(/\//g, '_')
			.replace(/=/g, '');
		testToken = `${data}.${encodedSignature}`;

		// Create a test file
		const magic = new TextEncoder().encode('SECF');
		const version = new Uint8Array([0x01]);
		const nonce = new Uint8Array(12);
		crypto.getRandomValues(nonce);
		const payload2 = new Uint8Array(20);
		const tag = new Uint8Array(16);
		const fileData = new Uint8Array([...magic, ...version, ...nonce, ...payload2, ...tag]);

		const createFileRequest = new Request(`http://example.com/${v1ApiPrefix}/file`, {
			method: 'POST',
			headers: { Authorization: `Bearer ${testToken}` },
			body: fileData,
		});

		ctx = createExecutionContext();
		const createFileResponse = await worker.fetch(createFileRequest, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(createFileResponse.status).toBe(201);

		const fileResult = await createFileResponse.json();
		testFileId = fileResult.file_id;
	});

	it('successfully deletes a file', async () => {
		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'DELETE',
			headers: { Authorization: `Bearer ${testToken}` },
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(200);
		const data = await response.json();
		expect(data.success).toBe(true);

		// Verify file was deleted from R2
		const storedFile = await env.BUCKET.get(testFileId);
		expect(storedFile).toBeNull();

		// Verify metadata was deleted from D1
		const result = await env.DB.prepare('SELECT * FROM files WHERE file_id = ?').bind(testFileId).first();

		expect(result).toBeNull();
	});

	it('rejects delete without authentication', async () => {
		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'DELETE',
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(401);
		const data = await response.json();
		expect(data.error).toContain('Authorization header required');
	});

	it('rejects delete of non-existent file', async () => {
		const fakeFileId = crypto.randomUUID();
		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${fakeFileId}`, {
			method: 'DELETE',
			headers: { Authorization: `Bearer ${testToken}` },
		});

		const ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(404);
		const data = await response.json();
		expect(data.error).toBe('File not found');
	});

	it('rejects delete by non-owner', async () => {
		// Create another user
		const otherPublicKey = btoa('k'.repeat(32));
		const createUserRequest = new Request(`http://example.com/${v1ApiPrefix}/user`, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ public_key: otherPublicKey, keychain_id: crypto.randomUUID() }),
		});

		let ctx = createExecutionContext();
		const createUserResponse = await worker.fetch(createUserRequest, env, ctx);
		await waitOnExecutionContext(ctx);

		const otherUserData = await createUserResponse.json();
		const otherUserId = otherUserData.user_id;

		// Create token for other user
		const jwtSecret = env.JWT_SECRET || 'default-jwt-secret-change-in-production';
		const now = Math.floor(Date.now() / 1000);
		const payload = {
			sub: otherUserId,
			iat: now,
			exp: now + 3600,
		};

		const header = { alg: 'HS256', typ: 'JWT' };
		const encodedHeader = btoa(JSON.stringify(header)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const encodedPayload = btoa(JSON.stringify(payload)).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
		const data = `${encodedHeader}.${encodedPayload}`;

		const encoder = new TextEncoder();
		const key = await crypto.subtle.importKey('raw', encoder.encode(jwtSecret), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

		const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
		const encodedSignature = btoa(String.fromCharCode(...new Uint8Array(signature)))
			.replace(/\+/g, '-')
			.replace(/\//g, '_')
			.replace(/=/g, '');
		const otherToken = `${data}.${encodedSignature}`;

		// Try to delete file with other user's token
		const request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'DELETE',
			headers: { Authorization: `Bearer ${otherToken}` },
		});

		ctx = createExecutionContext();
		const response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(403);
		const responseData = await response.json();
		expect(responseData.error).toBe('Not file owner');
	});

	it('allows deleting file twice (idempotent - second returns 404)', async () => {
		// First delete
		let request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'DELETE',
			headers: { Authorization: `Bearer ${testToken}` },
		});

		let ctx = createExecutionContext();
		let response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(200);

		// Second delete should return 404
		request = new Request(`http://example.com/${v1ApiPrefix}/file/${testFileId}`, {
			method: 'DELETE',
			headers: { Authorization: `Bearer ${testToken}` },
		});

		ctx = createExecutionContext();
		response = await worker.fetch(request, env, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(404);
		const data = await response.json();
		expect(data.error).toBe('File not found');
	});
});

// Helper function for tests
async function computeOwnerHashForTest(user_id, env) {
	const pepper = env.SERVER_PEPPER || 'default-pepper-change-in-production';
	const encoder = new TextEncoder();

	// Use HMAC-SHA256 as specified in design document
	const key = await crypto.subtle.importKey('raw', encoder.encode(pepper), { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']);

	const signature = await crypto.subtle.sign('HMAC', key, encoder.encode(user_id));

	const hashArray = Array.from(new Uint8Array(signature));
	return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

// Helper function to create and authenticate a test user
async function createAndAuthenticateTestUser() {
	// Create user
	const publicKey = btoa('test-user-key'.padEnd(32, '0'));
	let request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ public_key: publicKey, keychain_id: crypto.randomUUID() }),
	});
	let response = await worker.fetch(request, env, createExecutionContext());

	// Get challenge
	request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ public_key: publicKey }),
	});
	response = await worker.fetch(request, env, createExecutionContext());
	const challengeData = await response.json();

	// For testing, we'll create a valid signature using Ed25519
	// In a real test, you'd use a proper Ed25519 signing function
	// For now, we'll use a mock approach
	const encoder = new TextEncoder();
	encoder.encode(challengeData.challenge);

	// Generate Ed25519 key pair for testing
	const keyPair = await crypto.subtle.generateKey({ name: 'Ed25519', namedCurve: 'Ed25519' }, true, ['sign', 'verify']);

	// Export public key and create user with it
	const exportedPublicKey = await crypto.subtle.exportKey('raw', keyPair.publicKey);
	const realPublicKey = btoa(String.fromCharCode(...new Uint8Array(exportedPublicKey)));

	// Create user again with real key
	request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ public_key: realPublicKey, keychain_id: crypto.randomUUID() }),
	});
	response = await worker.fetch(request, env, createExecutionContext());
	const realUserData = await response.json();

	// Get new challenge
	request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({ public_key: realPublicKey }),
	});
	response = await worker.fetch(request, env, createExecutionContext());
	const realChallengeData = await response.json();

	// Sign with private key
	const signatureBytes = await crypto.subtle.sign('Ed25519', keyPair.privateKey, encoder.encode(realChallengeData.challenge));
	const signature = btoa(String.fromCharCode(...new Uint8Array(signatureBytes)));

	// Exchange signature for token
	request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify({
			public_key: realPublicKey,
			challenge: realChallengeData.challenge,
			signature: signature,
		}),
	});
	response = await worker.fetch(request, env, createExecutionContext());
	const tokenData = await response.json();

	return {
		user_id: realUserData.user_id,
		keychain_id: realUserData.keychain_id,
		token: tokenData.token,
		public_key: realPublicKey,
	};
}

// Helper function to create valid encrypted file data
function createValidFileData(filename = 'test.txt', content = 'Hello, World!') {
	// Create a valid SECF file format
	const magic = new TextEncoder().encode('SECF');
	const version = new Uint8Array([0x01]);
	const nonce = new Uint8Array(12).fill(0x42); // Mock nonce

	// Encode filename
	const filenameBytes = new TextEncoder().encode(filename);
	const filenameLengthBytes = new Uint8Array(2);
	new DataView(filenameLengthBytes.buffer).setUint16(0, filenameBytes.length);

	// Encode content
	const contentBytes = new TextEncoder().encode(content);

	// Create plaintext (this would be encrypted in real usage)
	const plaintext = new Uint8Array([...filenameLengthBytes, ...filenameBytes, ...contentBytes]);

	// Mock auth tag (in real usage, this comes from AES-GCM)
	const authTag = new Uint8Array(16).fill(0x99);

	// Combine all parts
	const fileData = new Uint8Array([...magic, ...version, ...nonce, ...plaintext, ...authTag]);

	return fileData;
}

describe('Rate Limiting', () => {
	beforeEach(async () => {
		// Clean up all tables before each test
		try {
			await env.DB.prepare('DELETE FROM users').run();
			await env.DB.prepare('DELETE FROM files').run();
			await env.DB.prepare('DELETE FROM auth_rate_limits').run();
			await env.DB.prepare('DELETE FROM registration_rate_limits').run();
			await env.DB.prepare('DELETE FROM file_operation_limits').run();
			await env.DB.prepare('DELETE FROM anonymous_download_limits').run();
		} catch {
			// Tables might not exist yet, that's ok
		}
	});

	describe('Registration Rate Limiting', () => {
		it('allows 3 registrations per hour from same fingerprint', async () => {
			const publicKey1 = btoa('a'.repeat(32));
			const publicKey2 = btoa('b'.repeat(32));
			const publicKey3 = btoa('c'.repeat(32));

			const headers = {
				'Content-Type': 'application/json',
				'CF-Connecting-IP': '1.2.3.4',
				'User-Agent': 'TestAgent',
				'Accept-Language': 'en-US',
			};

			// First registration
			let request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers,
				body: JSON.stringify({ public_key: publicKey1, keychain_id: crypto.randomUUID() }),
			});
			let response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(201);

			// Second registration
			request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers,
				body: JSON.stringify({ public_key: publicKey2, keychain_id: crypto.randomUUID() }),
			});
			response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(201);

			// Third registration
			request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers,
				body: JSON.stringify({ public_key: publicKey3, keychain_id: crypto.randomUUID() }),
			});
			response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(201);
		});

		it('blocks 4th registration from same fingerprint', async () => {
			const headers = {
				'Content-Type': 'application/json',
				'CF-Connecting-IP': '1.2.3.4',
				'User-Agent': 'TestAgent',
				'Accept-Language': 'en-US',
			};

			// Register 3 users
			for (let i = 0; i < 3; i++) {
				const publicKey = btoa(String.fromCharCode(97 + i).repeat(32));
				const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
					method: 'POST',
					headers,
					body: JSON.stringify({ public_key: publicKey, keychain_id: crypto.randomUUID() }),
				});
				await worker.fetch(request, env, createExecutionContext());
			}

			// 4th registration should be blocked
			const publicKey4 = btoa('d'.repeat(32));
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers,
				body: JSON.stringify({ public_key: publicKey4, keychain_id: crypto.randomUUID() }),
			});
			const response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(429);

			const data = await response.json();
			expect(data.error).toContain('rate limit');
		});

		it('allows registration with different fingerprint', async () => {
			const publicKey1 = btoa('a'.repeat(32));
			const publicKey2 = btoa('b'.repeat(32));

			// First registration
			let request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'CF-Connecting-IP': '1.2.3.4',
					'User-Agent': 'TestAgent1',
					'Accept-Language': 'en-US',
				},
				body: JSON.stringify({ public_key: publicKey1, keychain_id: crypto.randomUUID() }),
			});
			let response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(201);

			// Different User-Agent = different fingerprint, should succeed
			request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json',
					'CF-Connecting-IP': '1.2.3.4',
					'User-Agent': 'TestAgent2',
					'Accept-Language': 'en-US',
				},
				body: JSON.stringify({ public_key: publicKey2, keychain_id: crypto.randomUUID() }),
			});
			response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(201);
		});
	});

	describe('Authentication Rate Limiting', () => {
		let testUserId, testPublicKey;

		beforeEach(async () => {
			// Create a test user
			testPublicKey = btoa('test-public-key'.padEnd(32, '0'));
			const request = new Request(`http://example.com/${v1ApiPrefix}/user`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: testPublicKey, keychain_id: crypto.randomUUID() }),
			});
			const response = await worker.fetch(request, env, createExecutionContext());
			const data = await response.json();
			testUserId = data.user_id;
		});

		it('allows 10 challenge requests per minute from same IP', async () => {
			const headers = {
				'Content-Type': 'application/json',
				'CF-Connecting-IP': '2.3.4.5',
			};

			// Make 10 challenge requests
			for (let i = 0; i < 10; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
					method: 'POST',
					headers,
					body: JSON.stringify({ public_key: testPublicKey }),
				});
				const response = await worker.fetch(request, env, createExecutionContext());
				expect(response.status).toBe(200);
			}
		});

		it('blocks 11th challenge request from same IP', async () => {
			const headers = {
				'Content-Type': 'application/json',
				'CF-Connecting-IP': '2.3.4.5',
			};

			// Make 10 challenge requests
			for (let i = 0; i < 10; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
					method: 'POST',
					headers,
					body: JSON.stringify({ public_key: testPublicKey }),
				});
				await worker.fetch(request, env, createExecutionContext());
			}

			// 11th request should be blocked
			const request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers,
				body: JSON.stringify({ public_key: testPublicKey }),
			});
			const response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(429);

			const data = await response.json();
			expect(data.error).toContain('rate limit');
		});

		it('records failed authentication attempts', async () => {
			// Get challenge
			let request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ public_key: testPublicKey }),
			});
			let response = await worker.fetch(request, env, createExecutionContext());
			const challengeData = await response.json();

			// Try to authenticate with invalid signature (will fail)
			request = new Request(`http://example.com/${v1ApiPrefix}/auth/token`, {
				method: 'POST',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					public_key: testPublicKey,
					challenge: challengeData.challenge,
					signature: btoa('invalid-signature'.padEnd(64, '0')),
				}),
			});
			response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(401); // Invalid signature

			// Check that failed attempt was recorded
			const record = await env.DB.prepare('SELECT failed_attempts FROM auth_rate_limits WHERE id = ? AND type = ?')
				.bind(testUserId, 'user')
				.first();

			expect(record).toBeTruthy();
			expect(record.failed_attempts).toBeGreaterThan(0);
		});
	});

	describe('File Operation Rate Limiting', () => {
		let testUser, testToken;

		beforeEach(async () => {
			// Create and authenticate a test user
			testUser = await createAndAuthenticateTestUser();
			testToken = testUser.token;
		});

		it('blocks 51st read request', async () => {
			const headers = {
				Authorization: `Bearer ${testToken}`,
			};

			// Make 50 read requests
			for (let i = 0; i < 50; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
					method: 'GET',
					headers,
				});
				const response = await worker.fetch(request, env, createExecutionContext());

				expect(response.status, `Failed at iteration ${i + 1}`).toBe(200);
			}

			// 51st request should be blocked
			const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
				method: 'GET',
				headers,
			});
			const response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(429);

			const data = await response.json();
			expect(data.error).toContain('rate limit');
		});

		it('allows 20 write requests per minute', async () => {
			const headers = {
				Authorization: `Bearer ${testToken}`,
				'Content-Type': 'application/octet-stream',
			};

			// Create a valid encrypted file
			const fileData = createValidFileData();

			// Make 10 write requests (reduced for test performance)
			for (let i = 0; i < 10; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers,
					body: fileData,
				});
				const response = await worker.fetch(request, env, createExecutionContext());
				expect(response.status).toBe(201);
			}
		});

		it('blocks 21st write request', async () => {
			const headers = {
				Authorization: `Bearer ${testToken}`,
				'Content-Type': 'application/octet-stream',
			};

			const fileData = createValidFileData();

			// Make 20 write requests
			for (let i = 0; i < 20; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers,
					body: fileData,
				});
				await worker.fetch(request, env, createExecutionContext());
			}

			// 21st request should be blocked
			const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
				method: 'POST',
				headers,
				body: fileData,
			});
			const response = await worker.fetch(request, env, createExecutionContext());
			expect(response.status).toBe(429);

			const data = await response.json();
			expect(data.error).toContain('rate limit');
		});

		it('tracks read and write requests separately', async () => {
			const headers = {
				Authorization: `Bearer ${testToken}`,
			};

			// Make some read requests
			for (let i = 0; i < 10; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/files`, {
					method: 'GET',
					headers,
				});
				await worker.fetch(request, env, createExecutionContext());
			}

			// Make some write requests - should not be affected by read count
			const fileData = createValidFileData();
			for (let i = 0; i < 10; i++) {
				const request = new Request(`http://example.com/${v1ApiPrefix}/file`, {
					method: 'POST',
					headers: {
						...headers,
						'Content-Type': 'application/octet-stream',
					},
					body: fileData,
				});
				const response = await worker.fetch(request, env, createExecutionContext());
				expect(response.status).toBe(201);
			}
		});
	});
});
